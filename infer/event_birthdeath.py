import numpy as np
import copy
import sys
import traceback
import pdb
import pickle

from sigvisa.infer.propose import propose_event_from_hough
from sigvisa import Sigvisa
from sigvisa.graph.array_node import lldlld_X
from sigvisa.models.distributions import Gaussian

from sigvisa.infer.propose import generate_hough_array, propose_event_from_hough


def unass_template_logprob(sg, sta, template_dict):
    """

    return the log prob of a set of template parameters, under the
    model of unassociated templates at a station sta.

    """

    # HACK
    assert(len(sg.station_waves[sta]) == 1)
    wn = sg.station_waves[sta][0]

    tg = sg.template_generator(phase="UA")
    wg = sg.wiggle_generator(phase="UA")


    lp = 0
    for param in tg.params():
        model = tg.unassociated_model(param, nm=wn.nm)
        lp += model.log_p(template_dict[param])
    for param in wg.params():
        model = wg.unassociated_model(param, nm=wn.nm)
        lp += model.log_p(template_dict[param])
    return lp

def event_from_evnodes(evnodes):
    # TEMP: evnodes will return a single node, until I get around to splitting it up.
    return evnodes.get_event()

def param_logprob(sg, site, sta, ev, phase, chan, band, param, val, basisid=None):

    """

    return the log probability for an individual template parameter,
    as generated by an event phase arrival, WITHOUT interfering with
    the graph.

    """

    model_type = sg._tm_type(param, site=site)
    modelid = get_param_model_id(runid=sg.runid, sta=site,
                                 phase=phase, model_type=model_type,
                                 param=param, template_shape=sg.template_shape,
                                 chan=chan, band=band, basisid=basisid)
    model = load_modelid(modelid)

    if s.is_array_station(site):
        cond = lldlld_X(ev, sta)
    else:
        cond = ev

    return model.log_p(x = param, cond = cond)

def ev_phase_template_logprob(sg, sta, eid, phase, template_dict):

    """

    return log p(template params in template_dict) under the distribution generated by a phase arrival from event eid at station sta.

    """

    ev = event_from_nodes(sg.evnodes[eid])

    s = Sigvisa()
    site = s.get_array_site(sta)

    # HACK
    assert(len(sg.station_waves[sta]) == 1)
    wn = sg.station_waves[sta][0]
    basisid = sg.wiggle_generator(phase=phase, srate=wn.srate).basisid

    if 'tt_residual' not in template_dict:
        template_dict['tt_residual'] = tt_residual(ev, sta, template_dict['arrival_time'], phase=phase)
        del template_dict['arrival_time']

    # TODO: implement multiple bands/chans
    assert (len(sg.site_bands[site]) == 1)
    band = sg.site_bands[site][0]
    if 'amp_transfer' not in template_dict:
        template_dict['amp_transfer'] = amp_transfer(ev, band, phase, template_dict['coda_height'])
        del template_dict['coda_height']

    assert (len(sg.site_chans[site]) == 1)
    chan = sg.site_chans[site][0]

    lp = 0
    for param in template_dict.keys():
        lp += param_logprob(sg, site, sta, ev, phase, chan, band, param, val, basisid=basisid)
    return lp


def template_association_logodds(sg, sta, tmid, eid, phase):

    tmnodes = sg.uatemplates[tmid]
    param_values = dict([(k, n.get_value()) for (k,n) in tmnodes])

    lp_unass = unass_template_logprob(sg, sta, param_values)
    lp_ev = ev_phase_template_logprob(sg, sta, eid, phase, param_values)

    return lp_ev - lp_unass


def sample_template_to_associate(sg, sta, eid, phase):
    """
    Propose associating an unassociate template at sta with the
    (eid,phase) arrival, with probability proportional to the odds
    ratio p_{E,P}(T)/p_U(T). Alternately propose creating a new
    template, with probability proportional to p(N_U = n_U)/p(N_U =
    n_U - 1).

    Return:
    tmid: the unassociated template id proposed for
          association. (value of None indicates proposing a creation
          move)
    assoc_logprob: log probability of the proposal

    """

    c = Counter()
    for tmid in sg.uatemplate_ids[sta]:
        c[tmid] += np.exp(template_association_logodds(sg, sta, tmid, eid, phase))

    n_u = len(sg.uatemplate_ids[sta])
    c[None] = np.exp(sg.ntemplates_sta_log_p(sta, n=n_u) - sg.ntemplates_sta_log_p(sta, n=n_u-1))

    tmid = c.sample()
    assoc_logprob = np.log(c[tmid])

    return tmid, assoc_logprob

def associate_template(sg, sta, tmid, eid, phase):
    """

    Transform the graph to associate the template tmid with the arrival of eid/phase at sta.

    """

    tmnodes = sg.ua_templates[tmid]

    s = Sigvisa()
    site = s.get_array_site(sta)

    assert (len(sg.site_bands[site]) == 1)
    band = sg.site_bands[site][0]
    assert (len(sg.site_chans[site]) == 1)
    band = sg.site_chans[site][0]
    values = dict([(k, n.get_value()) for (k, n) in tmnodes.items()])
    sg.set_template(eid, sta, phase, band, chan, values)
    destroy_unassociated_template(self, tmnodes, nosort=True)
    return

def unassociate_template(sg, sta, eid, phase, tmid):

    s = Sigvisa()
    site = s.get_array_site(sta)

    assert (len(sg.site_bands[site]) == 1)
    band = sg.site_bands[site][0]
    assert (len(sg.site_chans[site]) == 1)
    band = sg.site_chans[site][0]
    ev_tmvals = sg.get_template_vals(eid, sta, phase, band, chan)

    wave_node = sg.station_waves[sta][0]
    atime = ev_tmvals['arrival_time']
    create_unassociated_template(self, wave_node, atime, wiggles=True, nosort=True,
                                 tmid=tmid, initial_vals=ev_tmvals)

    return

def deassociation_logprob(sg, sta, eid, phase):

    # return logprob of deassociating (vs deleting).

    assert (len(sg.site_bands[site]) == 1)
    band = sg.site_bands[site][0]
    assert (len(sg.site_chans[site]) == 1)
    band = sg.site_chans[site][0]
    ev_tmvals = sg.get_template_vals(eid, sta, phase, band, chan)

    unass_lp = unass_template_logprob(sg, sta, ev_tmvals)

    n_u = len(sg.uatemplate_ids[sta])
    ntemplates_ratio_log = sg.ntemplates_sta_log_p(sta, n=n_u+1) - sg.ntemplates_sta_log_p(sta, n=n_u)


    deassociation_ratio = np.exp( unass_lp + ntemplates_ratio_log)

    wave_node = sg.station_waves[sta][0]
    signal_lp_with_template = wave_node.log_p()
    arrivals = copy.copy(wave_node.arrivals())
    arrivals.remove((eid, phase))
    signal_lp_without_template = wave_node.log_p(arrivals=arrivals)
    deletion_ratio = np.exp(signal_lp_without_template - signal_lp_with_template)

    normalizer = deassociation_ratio + deletion_ratio

    return deassociation_ratio / normalizer

def get_signal_based_amplitude_distribution(sg, sta, tmvals, peak_period_s = 1.0):
    wn = sg.station_waves[sta][0]
    peak_time = tmvals['arrival_time'] + tmvals['peak_offset']
    peak_idx = int((peak_time - wn.stime) * wn.srate)
    peak_period_samples = int(peak_period_s * wn.srate)
    peak_data=wn.data[peak_idx - peak_period_samples:peak_idx + peak_period_samples]

    peak_height = np.mean(peak_data)
    env_height = peak_height - wn.nm.c

    return Gaussian(mean=np.log(env_height), std = 1.0)

def propose_phase_template(sg, sta, eid, phase):
    # sample a set of params for a phase template from an appropriate distribution (as described above).
    # return as an array.

    # we assume that add_event already sampled all the params parent-conditionally
    assert (len(sg.site_bands[site]) == 1)
    band = sg.site_bands[site][0]
    assert (len(sg.site_chans[site]) == 1)
    band = sg.site_chans[site][0]
    tmvals = sg.get_template_vals(eid, sta, phase, band, chan)
    del tmvals['coda_height']

    # compute log-prob of non-amplitude parameters
    lp = ev_phase_template_logprob(sg, sta, eid, phase, tmvals)

    # now we just sample an amplitude dependent on the signal
    amp_dist = get_signal_based_amplitude_distribution(sg, sta, tmvals)
    amplitude = amp_dist.sample()
    tmvals['coda_height'] = amplitude
    lp += amp_dist.log_p(amplitude)

    return tmvals, lp

def phase_template_proposal_logp(sg, sta, eid, phase, tmvals):
    # return the logprob of params from the proposal distribution

    tmvals = copy.copy(tmvals)
    amplitude = tmvals['coda_height']
    del tmvals['coda_height']

    lp = ev_phase_template_logprob(sg, sta, eid, phase, tmvals)

    amp_dist = get_signal_based_amplitude_distribution(sg, sta, tmvals)
    lp += amp_dist.log_p(amplitude)
    return lp

def ev_birth_move(sg):
    lp_old = sg.current_log_p()

    infer_stime = sg.start_time - 1000
    infer_etime = sg.end_time

    exclude_sites = ['STKA']
    hough_array = generate_hough_array(sg, stime=infer_stime, etime=infer_etime, bin_width_deg=4.0, exclude_sites=exclude_sites)
    proposed_ev, ev_prob = propose_event_from_hough(hough_array, infer_stime, infer_etime)
    print "proposed ev", proposed_ev

    forward_fns = []
    inverse_fns = []
    associations = []
    move_logprob = np.log(ev_prob)

    # add an event, WITH all its template nodes initialized to parent-sampled values.
    # we need to replace these values before computing any signal-based probabilities.
    # luckily,
    evnodes = sg.add_event(proposed_ev, sample_templates=True)
    print "added proposed event to graph"

    # loop over phase arrivals at each station and propose either
    # associating an existing unass. template with the new event, or
    # creating a new template.
    # don't modify the graph, but generate a list of functions
    # to execute the forward and reverse moves
    for elements in sg.site_elements.values():
        for sta in elements:
            for phase in sg.phases:
                tmid, assoc_logprob = sample_template_to_associate(sg, sta, eid, phase)
                if tmid is not None:
                    forward_fns.append(lambda : associate_template(sg, sta, tmid, eid, phase))
                    inverse_fns.append(lambda : unassociate_template(sg, sta, eid, phase))
                    associations.append((sta, phase, True))
                    print "proposing to associate template %d at %s,%p" % (tmid, sta, phase)
                    tmpl_lp  = 1.0
                else:
                    template_param_array, tmpl_lp = propose_phase_template(sg, sta, eid, phase)
                    forward_fns.append(lambda : set_template_vals(sg, sta, eid, phase, template_param_array))
                    inverse_fns.append(lambda : delete_template(sg, sta, eid, phase))
                    associations.append((sta, phase, False))
                    print "proposing to create template at %s,%p" % (sta, phase)
                sta_phase_logprob = assoc_logprob + tmpl_lp
                move_logprob += sta_phase_logprob


    # execute all the forward moves
    for fn in forward_fns:
        fn()
    sg._topo_sort()

    # compute log probability of the reverse move.
    # we have to do this in a separate loop so that
    # we can execute all the forward moves first.
    reverse_logprob = 0
    print "WARNING: NEED TO COMPUTE GLOBAL REVERSE LOGPROB"
    for (sta, phase, associated) in associations:
        if associated:
            reverse_logprob += np.log(deassociation_prob(sg, sta, eid, phase))
        else:
            reverse_logprob += np.log(1 - deassociation_prob(sg, sta, eid, phase))


    new_lp = sg.current_log_p()
    u = np.random.rand()
    move_accepted = (lp_new + reverse_logprob) - (lp_old + move_logprob) (lp_new + log_qbackward)  > np.log(u)
    if move_accepted:
        return new_ev_node
    else:
        for fn in inverse_fns:
            fn()
        return None

def main():

    f = open('cached_templates2.sg', 'rb')
    sg = pickle.load(f)
    f.close()

    print ev_birth_move(sg)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        raise
    except Exception as e:
        print e
        type, value, tb = sys.exc_info()
        traceback.print_exc()
        import pdb
        pdb.post_mortem(tb)
