

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sigvisa.results.mwmatching &mdash; SIG-VISA  documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="top" title="SIG-VISA  documentation" href="../../../../" />
    <link rel="up" title="Module code" href="../../../" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex/" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../">SIG-VISA  documentation</a> &raquo;</li>
          <li><a href="../../../" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sigvisa.results.mwmatching</h1><div class="highlight"><pre>
<span class="c"># Copyright (c) 2012, Bayesian Logic, Inc.</span>
<span class="c"># All rights reserved.</span>
<span class="c">#</span>
<span class="c"># Redistribution and use in source and binary forms, with or without</span>
<span class="c"># modification, are permitted provided that the following conditions are met:</span>
<span class="c">#     * Redistributions of source code must retain the above copyright</span>
<span class="c">#       notice, this list of conditions and the following disclaimer.</span>
<span class="c">#     * Redistributions in binary form must reproduce the above copyright</span>
<span class="c">#       notice, this list of conditions and the following disclaimer in the</span>
<span class="c">#       documentation and/or other materials provided with the distribution.</span>
<span class="c">#     * Neither the name of Bayesian Logic, Inc. nor the</span>
<span class="c">#       names of its contributors may be used to endorse or promote products</span>
<span class="c">#       derived from this software without specific prior written permission.</span>
<span class="c">#</span>
<span class="c"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="c"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="c"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="c"># FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</span>
<span class="c"># Bayesian Logic, Inc. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="c"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="c"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF</span>
<span class="c"># USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="c"># ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<span class="c"># OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
<span class="c"># OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
<span class="c"># SUCH DAMAGE.</span>
<span class="c">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">http://www.xs4all.nl/~rjoris/maximummatching.html</span>

<span class="sd">Weighted maximum matching in general graphs.</span>

<span class="sd">The algorithm is taken from &quot;Efficient Algorithms for Finding Maximum</span>
<span class="sd">Matching in Graphs&quot; by Zvi Galil, ACM Computing Surveys, 1986.</span>
<span class="sd">It is based on the &quot;blossom&quot; method for finding augmenting paths and</span>
<span class="sd">the &quot;primal-dual&quot; method for finding a matching of maximum weight, both</span>
<span class="sd">due to Jack Edmonds.</span>
<span class="sd">Some ideas came from &quot;Implementation of algorithms for maximum matching</span>
<span class="sd">on non-bipartite graphs&quot; by H.J. Gabow, Standford Ph.D. thesis, 1973.</span>

<span class="sd">A C program for maximum weight matching by Ed Rothberg was used extensively</span>
<span class="sd">to validate this new code.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># If assigned, DEBUG(str) is called with lots of debug messages.</span>
<span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">None</span>
<span class="sd">&quot;&quot;&quot;def DEBUG(s):</span>
<span class="sd">    from sys import stderr</span>
<span class="sd">    print &gt;&gt;stderr, &#39;DEBUG:&#39;, s</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># Check delta2/delta3 computation after every substage;</span>
<span class="c"># only works on integer weights, slows down the algorithm to O(n^4).</span>
<span class="n">CHECK_DELTA</span> <span class="o">=</span> <span class="bp">False</span>

<span class="c"># Check optimality of solution before returning; only works on integer weights.</span>
<span class="n">CHECK_OPTIMUM</span> <span class="o">=</span> <span class="bp">False</span>


<div class="viewcode-block" id="maxWeightMatching"><a class="viewcode-back" href="../../../../sigvisa.results/#sigvisa.results.mwmatching.maxWeightMatching">[docs]</a><span class="k">def</span> <span class="nf">maxWeightMatching</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">maxcardinality</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a maximum-weighted matching in the general undirected</span>
<span class="sd">    weighted graph given by &quot;edges&quot;.  If &quot;maxcardinality&quot; is true,</span>
<span class="sd">    only maximum-cardinality matchings are considered as solutions.</span>

<span class="sd">    Edges is a sequence of tuples (i, j, wt) describing an undirected</span>
<span class="sd">    edge between vertex i and vertex j with weight wt.  There is at most</span>
<span class="sd">    one edge between any two vertices; no vertex has an edge to itself.</span>
<span class="sd">    Vertices are identified by consecutive, non-negative integers.</span>

<span class="sd">    Return a list &quot;mate&quot;, such that mate[i] == j if vertex i is</span>
<span class="sd">    matched to vertex j, and mate[i] == -1 if vertex i is not matched.</span>

<span class="sd">    This function takes time O(n ** 3).&quot;&quot;&quot;</span>

    <span class="c">#</span>
    <span class="c"># Vertices are numbered 0 .. (nvertex-1).</span>
    <span class="c"># Non-trivial blossoms are numbered nvertex .. (2*nvertex-1)</span>
    <span class="c">#</span>
    <span class="c"># Edges are numbered 0 .. (nedge-1).</span>
    <span class="c"># Edge endpoints are numbered 0 .. (2*nedge-1), such that endpoints</span>
    <span class="c"># (2*k) and (2*k+1) both belong to edge k.</span>
    <span class="c">#</span>
    <span class="c"># Many terms used in the comments (sub-blossom, T-vertex) come from</span>
    <span class="c"># the paper by Galil; read the paper before reading this code.</span>
    <span class="c">#</span>

    <span class="c"># Deal swiftly with empty graphs.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c"># Count vertices.</span>
    <span class="n">nedge</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="n">nvertex</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">nvertex</span><span class="p">:</span>
            <span class="n">nvertex</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">nvertex</span><span class="p">:</span>
            <span class="n">nvertex</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c"># Find the maximum edge weight.</span>
    <span class="n">maxweight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">([</span><span class="n">wt</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]))</span>

    <span class="c"># If p is an edge endpoint,</span>
    <span class="c"># endpoint[p] is the vertex to which endpoint p is attached.</span>
    <span class="c"># Not modified by the algorithm.</span>
    <span class="n">endpoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">p</span> <span class="o">//</span> <span class="mi">2</span><span class="p">][</span><span class="n">p</span> <span class="o">%</span> <span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nedge</span><span class="p">)]</span>

    <span class="c"># If v is a vertex,</span>
    <span class="c"># neighbend[v] is the list of remote endpoints of the edges attached to v.</span>
    <span class="c"># Not modified by the algorithm.</span>
    <span class="n">neighbend</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)):</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">neighbend</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">neighbend</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>

    <span class="c"># If v is a vertex,</span>
    <span class="c"># mate[v] is the remote endpoint of its matched edge, or -1 if it is single</span>
    <span class="c"># (i.e. endpoint[mate[v]] is v&#39;s partner vertex).</span>
    <span class="c"># Initially all vertices are single; updated during augmentation.</span>
    <span class="n">mate</span> <span class="o">=</span> <span class="n">nvertex</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c"># If b is a top-level blossom,</span>
    <span class="c"># label[b] is 0 if b is unlabeled (free);</span>
    <span class="c">#             1 if b is an S-vertex/blossom;</span>
    <span class="c">#             2 if b is a T-vertex/blossom.</span>
    <span class="c"># The label of a vertex is found by looking at the label of its</span>
    <span class="c"># top-level containing blossom.</span>
    <span class="c"># If v is a vertex inside a T-blossom,</span>
    <span class="c"># label[v] is 2 iff v is reachable from an S-vertex outside the blossom.</span>
    <span class="c"># Labels are assigned during a stage and reset after each augmentation.</span>
    <span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># If b is a labeled top-level blossom,</span>
    <span class="c"># labelend[b] is the remote endpoint of the edge through which b obtained</span>
    <span class="c"># its label, or -1 if b&#39;s base vertex is single.</span>
    <span class="c"># If v is a vertex inside a T-blossom and label[v] == 2,</span>
    <span class="c"># labelend[v] is the remote endpoint of the edge through which v is</span>
    <span class="c"># reachable from outside the blossom.</span>
    <span class="n">labelend</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c"># If v is a vertex,</span>
    <span class="c"># inblossom[v] is the top-level blossom to which v belongs.</span>
    <span class="c"># If v is a top-level vertex, v is itself a blossom (a trivial blossom)</span>
    <span class="c"># and inblossom[v] == v.</span>
    <span class="c"># Initially all vertices are top-level trivial blossoms.</span>
    <span class="n">inblossom</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span class="p">)</span>

    <span class="c"># If b is a sub-blossom,</span>
    <span class="c"># blossomparent[b] is its immediate parent (sub-)blossom.</span>
    <span class="c"># If b is a top-level blossom, blossomparent[b] is -1.</span>
    <span class="n">blossomparent</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c"># If b is a non-trivial (sub-)blossom,</span>
    <span class="c"># blossomchilds[b] is an ordered list of its sub-blossoms, starting with</span>
    <span class="c"># the base and going round the blossom.</span>
    <span class="n">blossomchilds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="c"># If b is a (sub-)blossom,</span>
    <span class="c"># blossombase[b] is its base VERTEX (i.e. recursive sub-blossom).</span>
    <span class="n">blossombase</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span class="p">)</span> <span class="o">+</span> <span class="n">nvertex</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c"># If b is a non-trivial (sub-)blossom,</span>
    <span class="c"># blossomendps[b] is a list of endpoints on its connecting edges,</span>
    <span class="c"># such that blossomendps[b][i] is the local endpoint of blossomchilds[b][i]</span>
    <span class="c"># on the edge that connects it to blossomchilds[b][wrap(i+1)].</span>
    <span class="n">blossomendps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="c"># If v is a free vertex (or an unreached vertex inside a T-blossom),</span>
    <span class="c"># bestedge[v] is the edge to an S-vertex with least slack,</span>
    <span class="c"># or -1 if there is no such edge.</span>
    <span class="c"># If b is a (possibly trivial) top-level S-blossom,</span>
    <span class="c"># bestedge[b] is the least-slack edge to a different S-blossom,</span>
    <span class="c"># or -1 if there is no such edge.</span>
    <span class="c"># This is used for efficient computation of delta2 and delta3.</span>
    <span class="n">bestedge</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c"># If b is a non-trivial top-level S-blossom,</span>
    <span class="c"># blossombestedges[b] is a list of least-slack edges to neighbouring</span>
    <span class="c"># S-blossoms, or None if no such list has been computed yet.</span>
    <span class="c"># This is used for efficient computation of delta3.</span>
    <span class="n">blossombestedges</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="c"># List of currently unused blossom numbers.</span>
    <span class="n">unusedblossoms</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span>

    <span class="c"># If v is a vertex,</span>
    <span class="c"># dualvar[v] = 2 * u(v) where u(v) is the v&#39;s variable in the dual</span>
    <span class="c"># optimization problem (multiplication by two ensures integer values</span>
    <span class="c"># throughout the algorithm if all edge weights are integers).</span>
    <span class="c"># If b is a non-trivial blossom,</span>
    <span class="c"># dualvar[b] = z(b) where z(b) is b&#39;s variable in the dual optimization</span>
    <span class="c"># problem.</span>
    <span class="n">dualvar</span> <span class="o">=</span> <span class="n">nvertex</span> <span class="o">*</span> <span class="p">[</span><span class="n">maxweight</span><span class="p">]</span> <span class="o">+</span> <span class="n">nvertex</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># If allowedge[k] is true, edge k has zero slack in the optimization</span>
    <span class="c"># problem; if allowedge[k] is false, the edge&#39;s slack may or may not</span>
    <span class="c"># be zero.</span>
    <span class="n">allowedge</span> <span class="o">=</span> <span class="n">nedge</span> <span class="o">*</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span>

    <span class="c"># Queue of newly discovered S-vertices.</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Return 2 * slack of edge k (does not work inside blossoms).</span>
    <span class="k">def</span> <span class="nf">slack</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">wt</span>

    <span class="c"># Generate the leaf vertices of a blossom.</span>
    <span class="k">def</span> <span class="nf">blossomLeaves</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nvertex</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">nvertex</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">t</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">blossomLeaves</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">v</span>

    <span class="c"># Assign label t to the top-level blossom containing vertex w</span>
    <span class="c"># and record the fact that w was reached through the edge with</span>
    <span class="c"># remote endpoint p.</span>
    <span class="k">def</span> <span class="nf">assignLabel</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;assignLabel(</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">label</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
        <span class="n">labelend</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">bestedge</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># b became an S-vertex/blossom; add it(s vertices) to the queue.</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">blossomLeaves</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;PUSH &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">blossomLeaves</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c"># b became a T-vertex/blossom; assign label S to its mate.</span>
            <span class="c"># (If b is a non-trivial blossom, its base is the only vertex</span>
            <span class="c"># with an external mate.)</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">assignLabel</span><span class="p">(</span><span class="n">endpoint</span><span class="p">[</span><span class="n">mate</span><span class="p">[</span><span class="n">base</span><span class="p">]],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mate</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">^</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Trace back from vertices v and w to discover either a new blossom</span>
    <span class="c"># or an augmenting path. Return the base vertex of the new blossom or -1.</span>
    <span class="k">def</span> <span class="nf">scanBlossom</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;scanBlossom(</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="c"># Trace back from v and w, placing breadcrumbs as we go.</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">base</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">v</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c"># Look for a breadcrumb in v&#39;s blossom or put a new breadcrumb.</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                <span class="k">break</span>
            <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="c"># Trace one step back.</span>
            <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="n">mate</span><span class="p">[</span><span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c"># The base of blossom b is single; stop tracing this path.</span>
                <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="c"># b is a T-blossom; trace one more step back.</span>
                <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
            <span class="c"># Swap v and w so that we alternate between both paths.</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span>
       <span class="c"># Remove breadcrumbs.</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c"># Return base vertex, if we found one.</span>
        <span class="k">return</span> <span class="n">base</span>

    <span class="c"># Construct a new blossom with given base, containing edge k which</span>
    <span class="c"># connects a pair of S vertices. Label the new blossom as S; set its dual</span>
    <span class="c"># variable to zero; relabel its T-vertices to S and add them to the queue.</span>
    <span class="k">def</span> <span class="nf">addBlossom</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>
        <span class="n">bv</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
        <span class="c"># Create blossom.</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">unusedblossoms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;addBlossom(</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">) (v=</span><span class="si">%d</span><span class="s"> w=</span><span class="si">%d</span><span class="s">) -&gt; </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span>
        <span class="n">blossomparent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">blossomparent</span><span class="p">[</span><span class="n">bb</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="c"># Make list of sub-blossoms and their interconnecting edge endpoints.</span>
        <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">endps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Trace back from v to base.</span>
        <span class="k">while</span> <span class="n">bv</span> <span class="o">!=</span> <span class="n">bb</span><span class="p">:</span>
            <span class="c"># Add bv to the new blossom.</span>
            <span class="n">blossomparent</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bv</span><span class="p">)</span>
            <span class="n">endps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labelend</span><span class="p">[</span><span class="n">bv</span><span class="p">])</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">==</span> <span class="n">mate</span><span class="p">[</span><span class="n">blossombase</span><span class="p">[</span><span class="n">bv</span><span class="p">]]))</span>
            <span class="c"># Trace one step back.</span>
            <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">bv</span><span class="p">]]</span>
            <span class="n">bv</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="c"># Reverse lists, add endpoint that connects the pair of S vertices.</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">endps</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">endps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
        <span class="c"># Trace back from w to base.</span>
        <span class="k">while</span> <span class="n">bw</span> <span class="o">!=</span> <span class="n">bb</span><span class="p">:</span>
            <span class="c"># Add bw to the new blossom.</span>
            <span class="n">blossomparent</span><span class="p">[</span><span class="n">bw</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bw</span><span class="p">)</span>
            <span class="n">endps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labelend</span><span class="p">[</span><span class="n">bw</span><span class="p">]</span> <span class="o">^</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">bw</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">bw</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bw</span><span class="p">]</span> <span class="o">==</span> <span class="n">mate</span><span class="p">[</span><span class="n">blossombase</span><span class="p">[</span><span class="n">bw</span><span class="p">]]))</span>
            <span class="c"># Trace one step back.</span>
            <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bw</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">bw</span><span class="p">]]</span>
            <span class="n">bw</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
        <span class="c"># Set label to S.</span>
        <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">bb</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bb</span><span class="p">]</span>
        <span class="c"># Set dual variable to zero.</span>
        <span class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># Relabel vertices.</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">blossomLeaves</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c"># This T-vertex now turns into an S-vertex because it becomes</span>
                <span class="c"># part of an S-blossom; add it to the queue.</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="c"># Compute blossombestedges[b].</span>
        <span class="n">bestedgeto</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">bv</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">blossombestedges</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># This subblossom does not have a list of least-slack edges;</span>
                <span class="c"># get the information from the vertices.</span>
                <span class="n">nblists</span> <span class="o">=</span> <span class="p">[[</span><span class="n">p</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">neighbend</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span>
                           <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">blossomLeaves</span><span class="p">(</span><span class="n">bv</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Walk this subblossom&#39;s least-slack edges.</span>
                <span class="n">nblists</span> <span class="o">=</span> <span class="p">[</span><span class="n">blossombestedges</span><span class="p">[</span><span class="n">bv</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">nblist</span> <span class="ow">in</span> <span class="n">nblists</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nblist</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
                    <span class="n">bj</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">bj</span> <span class="o">!=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="n">bj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">bestedgeto</span><span class="p">[</span><span class="n">bj</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span>
                         <span class="n">slack</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">slack</span><span class="p">(</span><span class="n">bestedgeto</span><span class="p">[</span><span class="n">bj</span><span class="p">]))):</span>
                        <span class="n">bestedgeto</span><span class="p">[</span><span class="n">bj</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="c"># Forget about least-slack edges of the subblossom.</span>
            <span class="n">blossombestedges</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">bestedge</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">blossombestedges</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">bestedgeto</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c"># Select bestedge[b].</span>
        <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">blossombestedges</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">slack</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]):</span>
                <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;blossomchilds[</span><span class="si">%d</span><span class="s">]=&#39;</span> <span class="o">%</span> <span class="n">b</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]))</span>

    <span class="c"># Expand the given top-level blossom.</span>
    <span class="k">def</span> <span class="nf">expandBlossom</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">endstage</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;expandBlossom(</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">) </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">endstage</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">])))</span>
        <span class="c"># Convert sub-blossoms into top-level blossoms.</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
            <span class="n">blossomparent</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">nvertex</span><span class="p">:</span>
                <span class="n">inblossom</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
            <span class="k">elif</span> <span class="n">endstage</span> <span class="ow">and</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># Recursively expand this sub-blossom.</span>
                <span class="n">expandBlossom</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">endstage</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">blossomLeaves</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
        <span class="c"># If we expand a T-blossom during a stage, its sub-blossoms must be</span>
        <span class="c"># relabeled.</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">endstage</span><span class="p">)</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c"># Start at the sub-blossom through which the expanding</span>
            <span class="c"># blossom obtained its label, and relabel sub-blossoms untili</span>
            <span class="c"># we reach the base.</span>
            <span class="c"># Figure out through which sub-blossom the expanding blossom</span>
            <span class="c"># obtained its label initially.</span>
            <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">entrychild</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="c"># Decide in which direction we will go round the blossom.</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">entrychild</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># Start index is odd; go forward and wrap.</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">jstep</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">endptrick</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Start index is even; go backward.</span>
                <span class="n">jstep</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">endptrick</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c"># Move along the blossom until we get to the base.</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># Relabel the T-sub-blossom.</span>
                <span class="n">label</span><span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">label</span><span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">endptrick</span><span class="p">]</span> <span class="o">^</span> <span class="n">endptrick</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">assignLabel</span><span class="p">(</span><span class="n">endpoint</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="c"># Step to the next S-sub-blossom and note its forward endpoint.</span>
                <span class="n">allowedge</span><span class="p">[</span><span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">endptrick</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">endptrick</span><span class="p">]</span> <span class="o">^</span> <span class="n">endptrick</span>
                <span class="c"># Step to the next T-sub-blossom.</span>
                <span class="n">allowedge</span><span class="p">[</span><span class="n">p</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
            <span class="c"># Relabel the base T-sub-blossom WITHOUT stepping through to</span>
            <span class="c"># its mate (so don&#39;t call assignLabel).</span>
            <span class="n">bv</span> <span class="o">=</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">label</span><span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">labelend</span><span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">bestedge</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c"># Continue along the blossom until we get back to entrychild.</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
            <span class="k">while</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">entrychild</span><span class="p">:</span>
                <span class="c"># Examine the vertices of the sub-blossom to see whether</span>
                <span class="c"># it is reachable from a neighbouring S-vertex outside the</span>
                <span class="c"># expanding blossom.</span>
                <span class="n">bv</span> <span class="o">=</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c"># This sub-blossom just got label S through one of its</span>
                    <span class="c"># neighbours; leave it.</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">blossomLeaves</span><span class="p">(</span><span class="n">bv</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="c"># If the sub-blossom contains a reachable vertex, assign</span>
                <span class="c"># label T to the sub-blossom.</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="k">assert</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">bv</span>
                    <span class="n">label</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">label</span><span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="n">mate</span><span class="p">[</span><span class="n">blossombase</span><span class="p">[</span><span class="n">bv</span><span class="p">]]]]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">assignLabel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">labelend</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
        <span class="c"># Recycle the blossom number.</span>
        <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">blossombestedges</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">unusedblossoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="c"># Swap matched/unmatched edges over an alternating path through blossom b</span>
    <span class="c"># between vertex v and the base vertex. Keep blossom bookkeeping consistent.</span>
    <span class="k">def</span> <span class="nf">augmentBlossom</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;augmentBlossom(</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="c"># Bubble up through the blossom tree from vertex v to an immediate</span>
        <span class="c"># sub-blossom of b.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">while</span> <span class="n">blossomparent</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">blossomparent</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="c"># Recursively deal with the first sub-blossom.</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">nvertex</span><span class="p">:</span>
            <span class="n">augmentBlossom</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="c"># Decide in which direction we will go round the blossom.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># Start index is odd; go forward and wrap.</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="n">jstep</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">endptrick</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Start index is even; go backward.</span>
            <span class="n">jstep</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">endptrick</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c"># Move along the blossom until we get to the base.</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Step to the next sub-blossom and augment it recursively.</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">endptrick</span><span class="p">]</span> <span class="o">^</span> <span class="n">endptrick</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">nvertex</span><span class="p">:</span>
                <span class="n">augmentBlossom</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
            <span class="c"># Step to the next sub-blossom and augment it recursively.</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">nvertex</span><span class="p">:</span>
                <span class="n">augmentBlossom</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c"># Match the edge connecting those sub-blossoms.</span>
            <span class="n">mate</span><span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="n">p</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">^</span> <span class="mi">1</span>
            <span class="n">mate</span><span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;PAIR </span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s"> (k=</span><span class="si">%d</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">endpoint</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c"># Rotate the list of sub-blossoms to put the new base at the front.</span>
        <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">:]</span> <span class="o">+</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">][:</span><span class="n">i</span><span class="p">]</span>
        <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">:]</span> <span class="o">+</span> <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">][:</span><span class="n">i</span><span class="p">]</span>
        <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">assert</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span>

    <span class="c"># Swap matched/unmatched edges over an alternating path between two</span>
    <span class="c"># single vertices. The augmenting path runs through edge k, which</span>
    <span class="c"># connects a pair of S vertices.</span>
    <span class="k">def</span> <span class="nf">augmentMatching</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;augmentMatching(</span><span class="si">%d</span><span class="s">) (v=</span><span class="si">%d</span><span class="s"> w=</span><span class="si">%d</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;PAIR </span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s"> (k=</span><span class="si">%d</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">)):</span>
            <span class="c"># Match vertex s to remote endpoint p. Then trace back from s</span>
            <span class="c"># until we find a single vertex, swapping matched and unmatched</span>
            <span class="c"># edges as we go.</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bs</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">bs</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bs</span><span class="p">]</span> <span class="o">==</span> <span class="n">mate</span><span class="p">[</span><span class="n">blossombase</span><span class="p">[</span><span class="n">bs</span><span class="p">]]</span>
                <span class="c"># Augment through the S-blossom from s to base.</span>
                <span class="k">if</span> <span class="n">bs</span> <span class="o">&gt;=</span> <span class="n">nvertex</span><span class="p">:</span>
                    <span class="n">augmentBlossom</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="c"># Update mate[s]</span>
                <span class="n">mate</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
                <span class="c"># Trace one step back.</span>
                <span class="k">if</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bs</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c"># Reached single vertex; stop.</span>
                    <span class="k">break</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">bs</span><span class="p">]]</span>
                <span class="n">bt</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">bt</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="c"># Trace one step back.</span>
                <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bt</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">bt</span><span class="p">]]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">bt</span><span class="p">]</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>
                <span class="c"># Augment through the T-blossom from j to base.</span>
                <span class="k">assert</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">bt</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span>
                <span class="k">if</span> <span class="n">bt</span> <span class="o">&gt;=</span> <span class="n">nvertex</span><span class="p">:</span>
                    <span class="n">augmentBlossom</span><span class="p">(</span><span class="n">bt</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="c"># Update mate[j]</span>
                <span class="n">mate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bt</span><span class="p">]</span>
                <span class="c"># Keep the opposite endpoint;</span>
                <span class="c"># it will be assigned to mate[s] in the next step.</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bt</span><span class="p">]</span> <span class="o">^</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                    <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;PAIR </span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s"> (k=</span><span class="si">%d</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c"># Verify that the optimum solution has been reached.</span>
    <span class="k">def</span> <span class="nf">verifyOptimum</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">maxcardinality</span><span class="p">:</span>
            <span class="c"># Vertices may have negative dual;</span>
            <span class="c"># find a constant non-negative number to add to all vertex duals.</span>
            <span class="n">vdualoffset</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">dualvar</span><span class="p">[:</span><span class="n">nvertex</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vdualoffset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># 0. all dual variables are non-negative</span>
        <span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span class="n">dualvar</span><span class="p">[:</span><span class="n">nvertex</span><span class="p">])</span> <span class="o">+</span> <span class="n">vdualoffset</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span class="n">dualvar</span><span class="p">[</span><span class="n">nvertex</span><span class="p">:])</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="c"># 0. all edges have non-negative slack and</span>
        <span class="c"># 1. all matched edges have zero slack;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nedge</span><span class="p">):</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">wt</span>
            <span class="n">iblossoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">jblossoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">blossomparent</span><span class="p">[</span><span class="n">iblossoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">iblossoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">blossomparent</span><span class="p">[</span><span class="n">iblossoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">while</span> <span class="n">blossomparent</span><span class="p">[</span><span class="n">jblossoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">jblossoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">blossomparent</span><span class="p">[</span><span class="n">jblossoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">iblossoms</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">jblossoms</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="n">bj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iblossoms</span><span class="p">,</span> <span class="n">jblossoms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bi</span> <span class="o">!=</span> <span class="n">bj</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">mate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">k</span> <span class="ow">or</span> <span class="n">mate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">mate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">k</span>
                <span class="k">assert</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c"># 2. all single vertices have zero dual value;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">vdualoffset</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c"># 3. all blossoms with positive dual value are full.</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="n">p</span><span class="p">]]</span> <span class="o">==</span> <span class="n">p</span> <span class="o">^</span> <span class="mi">1</span>
                    <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="n">p</span>
        <span class="c"># Ok.</span>

    <span class="c"># Check optimized delta2 against a trivial computation.</span>
    <span class="k">def</span> <span class="nf">checkDelta2</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bd</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">bk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">neighbend</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">p</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">slack</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">bk</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">bd</span><span class="p">:</span>
                            <span class="n">bk</span> <span class="o">=</span> <span class="n">k</span>
                            <span class="n">bd</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">bk</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">bd</span> <span class="o">!=</span> <span class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">])):</span>
                    <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;v=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; bk=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; bd=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; bestedge=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                        <span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39; slack=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">])))</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">bk</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">bd</span> <span class="o">==</span> <span class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span>

    <span class="c"># Check optimized delta3 against a trivial computation.</span>
    <span class="k">def</span> <span class="nf">checkDelta3</span><span class="p">():</span>
        <span class="n">bk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">tbk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">tbd</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">blossomparent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">blossomLeaves</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">neighbend</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="n">p</span> <span class="o">//</span> <span class="mi">2</span>
                        <span class="n">w</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="n">slack</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">bk</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">bd</span><span class="p">:</span>
                                <span class="n">bk</span> <span class="o">=</span> <span class="n">k</span>
                                <span class="n">bd</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                    <span class="k">assert</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span> <span class="ow">or</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span>
                    <span class="k">assert</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span> <span class="ow">or</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span>
                    <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">tbk</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tbd</span><span class="p">:</span>
                        <span class="n">tbk</span> <span class="o">=</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                        <span class="n">tbd</span> <span class="o">=</span> <span class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="n">bd</span> <span class="o">!=</span> <span class="n">tbd</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;bk=</span><span class="si">%d</span><span class="s"> tbk=</span><span class="si">%d</span><span class="s"> bd=</span><span class="si">%s</span><span class="s"> tbd=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bk</span><span class="p">,</span> <span class="n">tbk</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">bd</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">tbd</span><span class="p">)))</span>
        <span class="k">assert</span> <span class="n">bd</span> <span class="o">==</span> <span class="n">tbd</span>

    <span class="c"># Main loop: continue until no further improvement is possible.</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>

        <span class="c"># Each iteration of this loop is a &quot;stage&quot;.</span>
        <span class="c"># A stage finds an augmenting path and uses that to improve</span>
        <span class="c"># the matching.</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;STAGE </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">)</span>

        <span class="c"># Remove labels from top-level blossoms/vertices.</span>
        <span class="n">label</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># Forget all about least-slack edges.</span>
        <span class="n">bestedge</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">blossombestedges</span><span class="p">[</span><span class="n">nvertex</span><span class="p">:]</span> <span class="o">=</span> <span class="n">nvertex</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

        <span class="c"># Loss of labeling means that we can not be sure that currently</span>
        <span class="c"># allowable edges remain allowable througout this stage.</span>
        <span class="n">allowedge</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nedge</span> <span class="o">*</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span>

        <span class="c"># Make queue empty.</span>
        <span class="n">queue</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># Label single blossoms/vertices with S and put them in the queue.</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mate</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">assignLabel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Loop until we succeed in augmenting the matching.</span>
        <span class="n">augmented</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>

            <span class="c"># Each iteration of this loop is a &quot;substage&quot;.</span>
            <span class="c"># A substage tries to find an augmenting path;</span>
            <span class="c"># if found, the path is used to improve the matching and</span>
            <span class="c"># the stage ends. If there is no augmenting path, the</span>
            <span class="c"># primal-dual method is used to pump some slack out of</span>
            <span class="c"># the dual variables.</span>
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;SUBSTAGE&#39;</span><span class="p">)</span>

            <span class="c"># Continue labeling until all vertices which are reachable</span>
            <span class="c"># through an alternating path have got a label.</span>
            <span class="k">while</span> <span class="n">queue</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">augmented</span><span class="p">:</span>

                <span class="c"># Take an S vertex from the queue.</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                    <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;POP v=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span>

                <span class="c"># Scan its neighbours:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">neighbend</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">p</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                    <span class="c"># w is a neighbour to v</span>
                    <span class="k">if</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                        <span class="c"># this edge is internal to a blossom; ignore it</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">allowedge</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">kslack</span> <span class="o">=</span> <span class="n">slack</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">kslack</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c"># edge k has zero slack =&gt; it is allowable</span>
                            <span class="n">allowedge</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">if</span> <span class="n">allowedge</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c"># (C1) w is a free vertex;</span>
                            <span class="c"># label w with T and label its mate with S (R12).</span>
                            <span class="n">assignLabel</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c"># (C2) w is an S-vertex (not in the same blossom);</span>
                            <span class="c"># follow back-links to discover either an</span>
                            <span class="c"># augmenting path or a new blossom.</span>
                            <span class="n">base</span> <span class="o">=</span> <span class="n">scanBlossom</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">base</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c"># Found a new blossom; add it to the blossom</span>
                                <span class="c"># bookkeeping and turn it into an S-blossom.</span>
                                <span class="n">addBlossom</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c"># Found an augmenting path; augment the</span>
                                <span class="c"># matching and end this stage.</span>
                                <span class="n">augmentMatching</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                <span class="n">augmented</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c"># w is inside a T-blossom, but w itself has not</span>
                            <span class="c"># yet been reached from outside the blossom;</span>
                            <span class="c"># mark it as reached (we need this to relabel</span>
                            <span class="c"># during T-blossom expansion).</span>
                            <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">2</span>
                            <span class="n">label</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                            <span class="n">labelend</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">^</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c"># keep track of the least-slack non-allowable edge to</span>
                        <span class="c"># a different S-blossom.</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">kslack</span> <span class="o">&lt;</span> <span class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]):</span>
                            <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c"># w is a free vertex (or an unreached vertex inside</span>
                        <span class="c"># a T-blossom) but we can not reach it yet;</span>
                        <span class="c"># keep track of the least-slack edge that reaches w.</span>
                        <span class="k">if</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">kslack</span> <span class="o">&lt;</span> <span class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">w</span><span class="p">]):</span>
                            <span class="n">bestedge</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

            <span class="k">if</span> <span class="n">augmented</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c"># There is no augmenting path under these constraints;</span>
            <span class="c"># compute delta and reduce slack in the optimization problem.</span>
            <span class="c"># (Note that our vertex dual variables, edge slacks and delta&#39;s</span>
            <span class="c"># are pre-multiplied by two.)</span>
            <span class="n">deltatype</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">deltaedge</span> <span class="o">=</span> <span class="n">deltablossom</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c"># Verify data structures for delta2/delta3 computation.</span>
            <span class="k">if</span> <span class="n">CHECK_DELTA</span><span class="p">:</span>
                <span class="n">checkDelta2</span><span class="p">()</span>
                <span class="n">checkDelta3</span><span class="p">()</span>

            <span class="c"># Compute delta1: the minumum value of any vertex dual.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">maxcardinality</span><span class="p">:</span>
                <span class="n">deltatype</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dualvar</span><span class="p">[:</span><span class="n">nvertex</span><span class="p">])</span>

            <span class="c"># Compute delta2: the minimum slack on any edge between</span>
            <span class="c"># an S-vertex and a free vertex.</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">deltatype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">:</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="n">deltatype</span> <span class="o">=</span> <span class="mi">2</span>
                        <span class="n">deltaedge</span> <span class="o">=</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

            <span class="c"># Compute delta3: half the minimum slack on any edge between</span>
            <span class="c"># a pair of S-blossoms.</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">blossomparent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                   <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">kslack</span> <span class="o">=</span> <span class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">kslack</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="p">(</span><span class="n">kslack</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">kslack</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">kslack</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="k">if</span> <span class="n">deltatype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">:</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="n">deltatype</span> <span class="o">=</span> <span class="mi">3</span>
                        <span class="n">deltaedge</span> <span class="o">=</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

            <span class="c"># Compute delta4: minimum z variable of any T-blossom.</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">blossomparent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span>
                   <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                   <span class="p">(</span><span class="n">deltatype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">)):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                    <span class="n">deltatype</span> <span class="o">=</span> <span class="mi">4</span>
                    <span class="n">deltablossom</span> <span class="o">=</span> <span class="n">b</span>

            <span class="k">if</span> <span class="n">deltatype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c"># No further improvement possible; max-cardinality optimum</span>
                <span class="c"># reached. Do a final delta update to make the optimum</span>
                <span class="c"># verifyable.</span>
                <span class="k">assert</span> <span class="n">maxcardinality</span>
                <span class="n">deltatype</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">dualvar</span><span class="p">[:</span><span class="n">nvertex</span><span class="p">]))</span>

            <span class="c"># Update dual variables according to delta.</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c"># S-vertex: 2*u = 2*u - 2*delta</span>
                    <span class="n">dualvar</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">delta</span>
                <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c"># T-vertex: 2*u = 2*u + 2*delta</span>
                    <span class="n">dualvar</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">blossomparent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c"># top-level S-blossom: z = z + 2*delta</span>
                        <span class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
                    <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c"># top-level T-blossom: z = z - 2*delta</span>
                        <span class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-=</span> <span class="n">delta</span>

            <span class="c"># Take action at the point where minimum delta occurred.</span>
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">DEBUG</span><span class="p">(</span><span class="s">&#39;delta</span><span class="si">%d</span><span class="s">=</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">deltatype</span><span class="p">,</span> <span class="n">delta</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">deltatype</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># No further improvement possible; optimum reached.</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">deltatype</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c"># Use the least-slack edge to continue the search.</span>
                <span class="n">allowedge</span><span class="p">[</span><span class="n">deltaedge</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">deltaedge</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">deltatype</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c"># Use the least-slack edge to continue the search.</span>
                <span class="n">allowedge</span><span class="p">[</span><span class="n">deltaedge</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">deltaedge</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">deltatype</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c"># Expand the least-z blossom.</span>
                <span class="n">expandBlossom</span><span class="p">(</span><span class="n">deltablossom</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

            <span class="c"># End of a this substage.</span>

        <span class="c"># Stop when no more augmenting path can be found.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">augmented</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c"># End of a stage; expand all S-blossoms which have dualvar = 0.</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">blossomparent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span>
               <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">expandBlossom</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

    <span class="c"># Verify that we reached the optimum solution.</span>
    <span class="k">if</span> <span class="n">CHECK_OPTIMUM</span><span class="p">:</span>
        <span class="n">verifyOptimum</span><span class="p">()</span>

    <span class="c"># Transform mate[] such that mate[v] is the vertex to which v is paired.</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mate</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mate</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">mate</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">mate</span><span class="p">[</span><span class="n">mate</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span class="n">v</span>

    <span class="k">return</span> <span class="n">mate</span>


<span class="c"># Unit tests</span></div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">unittest</span>
    <span class="kn">import</span> <span class="nn">math</span>

    <span class="k">class</span> <span class="nc">MaxWeightMatchingTests</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">test10_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># empty input graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([]),</span> <span class="p">[])</span>

        <span class="k">def</span> <span class="nf">test11_singleedge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># single edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test12</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test13</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test14_maxcard</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># maximum cardinality</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span> <span class="bp">True</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test15_float</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># floating point weigths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">(</span>
                <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test16_negative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># negative weights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span>
                <span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">)],</span> <span class="bp">False</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span>
                <span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">)],</span> <span class="bp">True</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test20_sblossom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create S-blossom and use it for augmentation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span>
                <span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test21_tblossom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create S-blossom, relabel as T-blossom, use for augmentation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span>
                <span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span>
                <span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span>
                <span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test22_s_nest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create nested S-blossom, use for augmentation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">(</span>
                <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test23_s_relabel_nest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create S-blossom, relabel as S, include in nested S-blossom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span>
                <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test24_s_nest_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create nested S-blossom, augment, expand recursively</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span>
                <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test25_s_t_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create S-blossom, relabel as T, expand</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">23</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span> <span class="p">(</span>
                <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">13</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test26_s_nest_t_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create nested S-blossom, relabel as T, expand</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">19</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span>
                <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test30_tnasty_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create blossom, relabel as T in more than one way, expand, augment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span>
                <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test31_tnasty2_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># again but slightly different</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span>
                <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test32_t_expand_leastslack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create blossom, relabel as T, expand such that a new least-slack S-to-free edge is produced, augment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span>
                <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test33_nest_tnasty_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create nested blossom, relabel as T in more than one way, expand outer</span>
            <span class="c"># blossom such that inner blossom ends up on an augmenting path</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">95</span><span class="p">),</span> <span class="p">(</span>
                <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">94</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">94</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">36</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">test34_nest_relabel_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># create nested S-blossom, relabel as S, expand recursively</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">maxWeightMatching</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">55</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">55</span><span class="p">),</span> <span class="p">(</span>
                <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">30</span><span class="p">)]),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>

    <span class="n">CHECK_DELTA</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>

<span class="c"># end</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search/" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex/" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../">SIG-VISA  documentation</a> &raquo;</li>
          <li><a href="../../../" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, David Moore.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>