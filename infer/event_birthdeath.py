import numpy as np
import copy
import sys
import traceback
import pdb
import pickle


from sigvisa import Sigvisa
from sigvisa.graph.array_node import lldlld_X
from sigvisa.graph.sigvisa_graph import get_param_model_id
from sigvisa.models.distributions import Gaussian
from sigvisa.models.ttime import tt_residual
from sigvisa.models.templates.coda_height import amp_transfer
from sigvisa.utils.counter import Counter
from sigvisa.infer.propose import generate_hough_array, propose_event_from_hough
from sigvisa.learn.train_param_common import load_modelid

def unass_template_logprob(sg, sta, template_dict):
    """

    return the log prob of a set of template parameters, under the
    model of unassociated templates at a station sta.

    """

    # HACK
    assert(len(sg.station_waves[sta]) == 1)
    wn = sg.station_waves[sta][0]

    tg = sg.template_generator(phase="UA")
    wg = sg.wiggle_generator(phase="UA", srate=wn.srate)


    lp = 0
    for param in tg.params():
        model = tg.unassociated_model(param, nm=wn.nm)
        lp += model.log_p(template_dict[param])
    for param in wg.params():
        model = wg.unassociated_model(param, nm=wn.nm)
        lp += model.log_p(template_dict[param])
    return lp

def event_from_evnodes(evnodes):
    # TEMP: evnodes will return a single node, until I get around to splitting it up.
    return evnodes.get_event()

def param_logprob(sg, site, sta, ev, phase, chan, band, param, val, basisid=None):

    """

    return the log probability for an individual template parameter,
    as generated by an event phase arrival, WITHOUT interfering with
    the graph.

    """

    model_type = sg._tm_type(param, site=site)

    s = Sigvisa()
    if s.is_array_station(site) and sg.arrays_joint:
        modelid = get_param_model_id(runid=sg.runid, sta=site,
                                     phase=phase, model_type=model_type,
                                     param=param, template_shape=sg.template_shape,
                                     chan=chan, band=band, basisid=basisid)
        cond = lldlld_X(ev, sta)
    else:
        modelid = get_param_model_id(runid=sg.runid, sta=sta,
                                     phase=phase, model_type=model_type,
                                     param=param, template_shape=sg.template_shape,
                                     chan=chan, band=band, basisid=basisid)
        cond = ev

    model = load_modelid(modelid)
    return model.log_p(x = val, cond = cond)

def ev_phase_template_logprob(sg, sta, eid, phase, template_dict):

    """

    return log p(template params in template_dict) under the distribution generated by a phase arrival from event eid at station sta.

    """

    ev = event_from_evnodes(sg.evnodes[eid])

    s = Sigvisa()
    site = s.get_array_site(sta)

    # HACK
    assert(len(sg.station_waves[sta]) == 1)
    wn = sg.station_waves[sta][0]
    wg = sg.wiggle_generator(phase=phase, srate=wn.srate)
    wiggle_params = set(wg.params())

    if 'tt_residual' not in template_dict:
        template_dict['tt_residual'] = tt_residual(ev, sta, template_dict['arrival_time'], phase=phase)

    # TODO: implement multiple bands/chans
    assert (len(list(sg.site_bands[site])) == 1)
    band = list(sg.site_bands[site])[0]
    if 'amp_transfer' not in template_dict:
        template_dict['amp_transfer'] = amp_transfer(ev, band, phase, template_dict['coda_height'])

    assert (len(list(sg.site_chans[site])) == 1)
    chan = list(sg.site_chans[site])[0]

    lp = 0
    for (param, val) in template_dict.items():
        if param in ('arrival_time', 'coda_height'): continue
        if param in wiggle_params:
            basisid = wg.basisid
        else:
            basisid = None
        lp_param = param_logprob(sg, site, sta, ev, phase, chan, band, param, val, basisid=basisid)
        lp += lp_param
        print sta, phase, param, val, lp_param
    return lp


def template_association_logodds(sg, sta, tmid, eid, phase):

    tmnodes = sg.uatemplates[tmid]
    param_values = dict([(k, n.get_value()) for (k,n) in tmnodes.items()])

    lp_unass = unass_template_logprob(sg, sta, param_values)
    lp_ev = ev_phase_template_logprob(sg, sta, eid, phase, param_values)

    return lp_ev - lp_unass


def sample_template_to_associate(sg, sta, eid, phase):
    """
    Propose associating an unassociate template at sta with the
    (eid,phase) arrival, with probability proportional to the odds
    ratio p_{E,P}(T)/p_U(T). Alternately propose creating a new
    template, with probability proportional to p(N_U = n_U)/p(N_U =
    n_U - 1).

    Return:
    tmid: the unassociated template id proposed for
          association. (value of None indicates proposing a creation
          move)
    assoc_logprob: log probability of the proposal

    """

    s = Sigvisa()
    site = s.get_array_site(sta)

    assert (len(list(sg.site_bands[site])) == 1)
    band = list(sg.site_bands[site])[0]
    assert (len(list(sg.site_chans[site])) == 1)
    chan = list(sg.site_chans[site])[0]

    c = Counter()
    for tmid in sg.uatemplate_ids[(sta,chan,band)]:
        c[tmid] += np.exp(template_association_logodds(sg, sta, tmid, eid, phase))

    # if there are no unassociated templates, there's nothing to sample.
    n_u = len(sg.uatemplate_ids[(sta, chan, band)])
    print sta, n_u
    if n_u == 0:
        return None, 0.0

    c[None] = np.exp(sg.ntemplates_sta_log_p(sta, n=n_u) - sg.ntemplates_sta_log_p(sta, n=n_u-1))
    c.normalize()
    tmid = c.sample()
    assoc_logprob = np.log(c[tmid])

    return tmid, assoc_logprob

def associate_template(sg, sta, tmid, eid, phase):
    """

    Transform the graph to associate the template tmid with the arrival of eid/phase at sta.

    """

    tmnodes = sg.uatemplates[tmid]

    s = Sigvisa()
    site = s.get_array_site(sta)

    assert (len(list(sg.site_bands[site])) == 1)
    band = list(sg.site_bands[site])[0]
    assert (len(list(sg.site_chans[site])) == 1)
    chan = list(sg.site_chans[site])[0]
    values = dict([(k, n.get_value()) for (k, n) in tmnodes.items()])
    sg.set_template(eid, sta, phase, band, chan, values)
    destroy_unassociated_template(self, tmnodes, nosort=True)
    return

def unassociate_template(sg, sta, eid, phase, tmid):

    s = Sigvisa()
    site = s.get_array_site(sta)

    assert (len(list(sg.site_bands[site])) == 1)
    band = list(sg.site_bands[site])[0]
    assert (len(list(sg.site_chans[site])) == 1)
    chan = list(sg.site_chans[site])[0]
    ev_tmvals = sg.get_template_vals(eid, sta, phase, band, chan)

    wave_node = sg.station_waves[sta][0]
    atime = ev_tmvals['arrival_time']
    create_unassociated_template(self, wave_node, atime, wiggles=True, nosort=True,
                                 tmid=tmid, initial_vals=ev_tmvals)

    return

def deassociation_prob(sg, sta, eid, phase):

    # return prob of deassociating (vs deleting).

    s = Sigvisa()
    site = s.get_array_site(sta)


    assert (len(list(sg.site_bands[site])) == 1)
    band = list(sg.site_bands[site])[0]
    assert (len(list(sg.site_chans[site])) == 1)
    chan = list(sg.site_chans[site])[0]
    ev_tmvals = sg.get_template_vals(eid, sta, phase, band, chan)

    unass_lp = unass_template_logprob(sg, sta, ev_tmvals)

    n_u = len(sg.uatemplate_ids[(sta,chan,band)])
    ntemplates_ratio_log = sg.ntemplates_sta_log_p(sta, n=n_u+1) - sg.ntemplates_sta_log_p(sta, n=n_u)


    deassociation_ratio = np.exp( unass_lp + ntemplates_ratio_log)

    wave_node = sg.station_waves[sta][0]
    signal_lp_with_template = wave_node.log_p()
    arrivals = copy.copy(wave_node.arrivals())
    arrivals.remove((eid, phase))
    signal_lp_without_template = wave_node.log_p(arrivals=arrivals)
    deletion_ratio = np.exp(signal_lp_without_template - signal_lp_with_template)

    normalizer = deassociation_ratio + deletion_ratio

    return deassociation_ratio / normalizer

def get_signal_based_amplitude_distribution(sg, sta, tmvals, peak_period_s = 1.0):
    wn = sg.station_waves[sta][0]
    peak_time = tmvals['arrival_time'] + tmvals['peak_offset']
    peak_idx = int((peak_time - wn.st) * wn.srate)
    peak_period_samples = int(peak_period_s * wn.srate)
    peak_data=wn.get_value()[peak_idx - peak_period_samples:peak_idx + peak_period_samples]

    peak_height = np.mean(peak_data)
    env_height = max(peak_height - wn.nm.c, wn.nm.c/100.0)

    return Gaussian(mean=np.log(env_height), std = 1.0)

def propose_phase_template(sg, sta, eid, phase):
    # sample a set of params for a phase template from an appropriate distribution (as described above).
    # return as an array.

    s = Sigvisa()
    site = s.get_array_site(sta)

    # we assume that add_event already sampled all the params parent-conditionally
    assert (len(list(sg.site_bands[site])) == 1)
    band = list(sg.site_bands[site])[0]
    assert (len(list(sg.site_chans[site])) == 1)
    chan = list(sg.site_chans[site])[0]
    tmvals = sg.get_template_vals(eid, sta, phase, band, chan)
    del tmvals['coda_height']


    # compute log-prob of non-amplitude parameters
    lp = ev_phase_template_logprob(sg, sta, eid, phase, tmvals)

    # now we just sample an amplitude dependent on the signal
    amp_dist = get_signal_based_amplitude_distribution(sg, sta, tmvals)
    amplitude = amp_dist.sample()
    tmvals['coda_height'] = amplitude
    lp += amp_dist.log_p(amplitude)

    return tmvals, lp

def phase_template_proposal_logp(sg, sta, eid, phase, tmvals):
    # return the logprob of params from the proposal distribution

    tmvals = copy.copy(tmvals)
    amplitude = tmvals['coda_height']
    del tmvals['coda_height']

    lp = ev_phase_template_logprob(sg, sta, eid, phase, tmvals)

    amp_dist = get_signal_based_amplitude_distribution(sg, sta, tmvals)
    lp += amp_dist.log_p(amplitude)
    return lp

def ev_birth_move(sg):
    lp_old = sg.current_log_p()

    infer_stime = sg.start_time - 1000
    infer_etime = sg.end_time

    exclude_sites = ['STKA']
    hough_array = generate_hough_array(sg, stime=infer_stime, etime=infer_etime, bin_width_deg=4.0, exclude_sites=exclude_sites)
    proposed_ev, ev_prob = propose_event_from_hough(hough_array, infer_stime, infer_etime)
    print "proposed ev", proposed_ev

    forward_fns = []
    inverse_fns = []
    associations = []
    move_logprob = np.log(ev_prob)

    # add an event, WITH all its template nodes initialized to parent-sampled values.
    # we need to replace these values before computing any signal-based probabilities.
    # luckily,
    evnodes = sg.add_event(proposed_ev, sample_templates=True)
    eid = evnodes.eid
    print "added proposed event to graph"

    # loop over phase arrivals at each station and propose either
    # associating an existing unass. template with the new event, or
    # creating a new template.
    # don't modify the graph, but generate a list of functions
    # to execute the forward and reverse moves
    for elements in sg.site_elements.values():
        for sta in elements:

            s = Sigvisa()
            site = s.get_array_site(sta)
            assert (len(list(sg.site_bands[site])) == 1)
            band = list(sg.site_bands[site])[0]
            assert (len(list(sg.site_chans[site])) == 1)
            chan = list(sg.site_chans[site])[0]

            for phase in sg.phases:
                tmid, assoc_logprob = sample_template_to_associate(sg, sta, eid, phase)
                if tmid is not None:
                    forward_fns.append(lambda : associate_template(sg, sta, tmid, eid, phase))
                    inverse_fns.append(lambda : unassociate_template(sg, sta, eid, phase))
                    associations.append((sta, phase, True))
                    print "proposing to associate template %d at %s,%s with assoc lp %.1f" % (tmid, sta, phase, assoc_logprob)
                    tmpl_lp  = 0.0
                else:
                    template_param_array, tmpl_lp = propose_phase_template(sg, sta, eid, phase)
                    forward_fns.append(lambda : sg.set_template(eid,sta, phase, band, chan, template_param_array))
                    inverse_fns.append(lambda : delete_template(sg, sta, eid, phase))
                    associations.append((sta, phase, False))
                    print "proposing to create template at %s,%s with assoc lp %.1f" % (sta, phase, assoc_logprob)

                sta_phase_logprob = assoc_logprob + tmpl_lp
                move_logprob += sta_phase_logprob
                print "LOGPROBS: ", assoc_logprob, tmpl_lp, sta_phase_logprob, move_logprob
                if np.isinf(move_logprob):
                    import pdb; pdb.set_trace()

    # execute all the forward moves
    for fn in forward_fns:
        fn()
    sg._topo_sort()

    # compute log probability of the reverse move.
    # we have to do this in a separate loop so that
    # we can execute all the forward moves first.
    reverse_logprob = 0
    print "WARNING: NEED TO COMPUTE GLOBAL REVERSE LOGPROB"
    for (sta, phase, associated) in associations:
        if associated:
            reverse_logprob += np.log(deassociation_prob(sg, sta, eid, phase))
        else:
            reverse_logprob += np.log(1 - deassociation_prob(sg, sta, eid, phase))


    lp_new = sg.current_log_p()
    u = np.random.rand()
    move_accepted = (lp_new + reverse_logprob) - (lp_old + move_logprob)  > np.log(u)
    if move_accepted:
        print "move accepted"
        import pdb; pdb.set_trace()
        return new_ev_node
    else:
        print "move rejected"
        for fn in inverse_fns:
            fn()
        print "changes reverted"
        return None

def main():

    f = open('cached_templates2.sg', 'rb')
    sg = pickle.load(f)
    f.close()

    sg.runid = 17

    print ev_birth_move(sg)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        raise
    except Exception as e:
        print e
        type, value, tb = sys.exc_info()
        traceback.print_exc()
        import pdb
        pdb.post_mortem(tb)
